import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

import { Select2, Select2Hint } from './angular.component';

@NgModule({
    declarations: [
        Select2Hint,
        Select2
    ],
    imports: [
        CommonModule
    ],
    exports: [
        Select2Hint,
        Select2
    ]
})
export class Select2Module { }

<<<<<<< HEAD
    mouseenter(option: common.Select2Option) {
        if (!option.disabled) {
            this.hoveringValue = option.value;
        }
    }

    click(option: common.Select2Option) {
        this._keeper = false;
        if (!option.disabled) {
            this.select(option);
        }
        if (this.focusoutTimer) {
            clearTimeout(this.focusoutTimer);
        }
    }

    toggleOpenAndClose() {
        if (this.disabled) {
            return;
        }
        this.focused = true;
        this.isOpen = !this.isOpen;
        if (this.isOpen) {
            this.innerSearchText = '';
            if (!this.isSearchboxHidden) {
                if (this.searchInputElement) {
                    this.searchInputElement.focus();
                }
            } else {
                if (this.resultsElement) {
                    this.resultsElement.focus();
                }
            }

            if (this.resultsElement) {
                const lastScrollTopIndex = common.getLastScrollTopIndex(
                    this.hoveringValue,
                    this.resultsElement,
                    this.data,
                    this.lastScrollTopIndex
                );
                if (lastScrollTopIndex !== null) {
                    this.lastScrollTopIndex = lastScrollTopIndex;
                }
            }
            this.open.emit();
        }
        if (this.focusoutTimer) {
            clearTimeout(this.focusoutTimer);
        }
    }

    focusin() {
        this.focuskeeper();
        if (!this.disabled) {
            this.focused = true;
        }
    }

    focuskeeper() {
        this._keeper = true;
        setTimeout(() => {
            this._keeper = false;
        }, common.timeout);
    }

    focusout(field: string) {
        this.focusoutTimer = setTimeout(() => {
            if (
                (this.focused && !this.isOpen && this._keeper === false)
                || (field === 'searchInput' && this._keeper === false)
                || (field === 'option' && this._keeper === false)
            ) {
                this.isOpen = false;
                this.focusoutTimer = undefined;
                if (!this.selectionElement.classList.contains('select2-focus')) {
                    this.focused = false;
                    this._onTouched();
                    this._changeDetectorRef.markForCheck();
                }
            }
            this._keeper = false;
        }, common.timeout);
    }

    moveUp() {
        this.hoveringValue = common.getPreviousOption(this.filteredData, this.hoveringValue);

        if (this.resultsElement) {
            const lastScrollTopIndex = common.getLastScrollTopIndex(
                this.hoveringValue,
                this.resultsElement,
                this.filteredData,
                this.lastScrollTopIndex
            );
            if (lastScrollTopIndex !== null) {
                this.lastScrollTopIndex = lastScrollTopIndex;
            }
        }
    }

    moveDown() {
        this.hoveringValue = common.getNextOption(this.filteredData, this.hoveringValue);

        if (this.resultsElement) {
            const lastScrollTopIndex = common.getLastScrollTopIndex(
                this.hoveringValue,
                this.resultsElement,
                this.filteredData,
                this.lastScrollTopIndex
            );
            if (lastScrollTopIndex !== null) {
                this.lastScrollTopIndex = lastScrollTopIndex;
            }
        }
    }

    selectByEnter() {
        if (this.hoveringValue) {
            const option = common.getOptionByValue(this.data, this.hoveringValue);
            this.select(option);
        }
    }

    select(option: common.Select2Option | null) {
        if (option !== null) {
            if (this.multiple) {
                const options = this.option as common.Select2Option[];
                let index = -1;
                for (let i = 0; i < options.length; i++) {
                    if (options[i].value === option.value) {
                        index = i;
                        break;
                    }
                }
                if (index === -1) {
                    options.push(option);
                } else {
                    options.splice(index, 1);
                }
            } else {
                this.option = option;
                this.isOpen = false;
                this.selectionElement.focus();
                this.focuskeeper();
            }
        }

        let value = this.multiple
            ? (this.option as common.Select2Option[]).map(op => op.value)
            : (this.option as common.Select2Option).value;

        if (this._control) {
            this._control.reset(value);
            this._onChange(value);
        }
        this.update.emit(value);
    }

    keyDown(e: KeyboardEvent) {
        if (e.keyCode === 40) {
            this.moveDown();
            e.preventDefault();
        } else if (e.keyCode === 38) {
            this.moveUp();
            e.preventDefault();
        } else if (e.keyCode === 13) {
            this.selectByEnter();
            e.preventDefault();
        } else if (e.keyCode === 9 && this.isOpen) {
            this.toggleOpenAndClose();
            this.focused = false;
        }
    }

    openKey(e: KeyboardEvent) {
        if (e.keyCode === 40 || e.keyCode === 38 || e.keyCode === 13) {
            this.toggleOpenAndClose();
            e.preventDefault();
        } else if (e.keyCode === 9) {
            this.focused = false;
            this._onTouched();
        }
    }

    searchUpdate(e: Event) {
        this.searchText = (<HTMLInputElement>e.target).value;
    }

    isSelected(option: common.Select2Option) {
        return common.isSelected(this.option, option, this.multiple);
    }

    isDisabled(option: common.Select2Option) {
        return option.disabled ? 'true' : 'false';
    }

    removeSelection(e: MouseEvent, option: common.Select2Option) {
        common.removeSelection(this.option, option);
        this.update.emit((this.option as common.Select2Option[]).map(op => op.value));

        e.preventDefault();
        e.stopPropagation();

        if (this.isOpen) {
            if (!this.isSearchboxHidden) {
                if (this.searchInputElement) {
                    this.searchInputElement.focus();
                }
            } else {
                if (this.resultsElement) {
                    this.resultsElement.focus();
                }
            }
        }

        if (this.focusoutTimer) {
            clearTimeout(this.focusoutTimer);
        }
    }

    /**
     * Sets the model value. Implemented as part of ControlValueAccessor.
     * @param value
     */
    writeValue(value: any) {
        this._setSelectionByValue(value);
    }

    /**
     * Saves a callback function to be invoked when the select's value
     * changes from user input. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param fn Callback to be triggered when the value changes.
     */
    registerOnChange(fn: (value: any) => void): void {
        this._onChange = fn;
    }

    /**
     * Saves a callback function to be invoked when the select is blurred
     * by the user. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param fn Callback to be triggered when the component has been touched.
     */
    registerOnTouched(fn: () => {}): void {
        this._onTouched = fn;
    }

    /**
     * Sets whether the component should be disabled.
     * Implemented as part of ControlValueAccessor.
     * @param isDisabled
     */
    setDisabledState(isDisabled: boolean) {
        this.disabled = isDisabled;
    }

    _isErrorState(): boolean {
        const isInvalid = this._control && this._control.invalid;
        const isTouched = this._control && this._control.touched;
        const isSubmitted = (this._parentFormGroup && this._parentFormGroup.submitted) ||
            (this._parentForm && this._parentForm.submitted);

        return !!(isInvalid && (isTouched || isSubmitted));
    }

    /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     */
    private _setSelectionByValue(value: any | any[]): void {
        const isArray = Array.isArray(value);

        if (this.multiple && value && !isArray) {
            throw 'Non array value.';
        }

        this._changeDetectorRef.markForCheck();
    }


    /** Does some manual dirty checking on the native input `value` property. */
    private _dirtyCheckNativeValue() {
        const newValue = this.value;

        if (this._previousNativeValue !== newValue) {
            this._previousNativeValue = newValue;
            this._stateChanges.next();
        }
    }

    private _coerceBooleanProperty(value: any): boolean {
        return value != null && `${value}` !== 'false';
    }
}
=======
export * from './angular.component';
export * from './common';
>>>>>>> Renaming file & change for  build test
